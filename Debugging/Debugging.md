# Debugging And Exception Handling
>

## 디버깅
> RxJava는 try-catch 문을 사용할 수 없기 때문에 디버깅을 하기 어렵다.
하지만 RxJava에서 지원하는 함수를 사용하면 손쉽게 할 수 있다.

- #### doOnNext() : 어떤 데이터가 발행되면 이벤트 발생
- #### doOnComplete() : 모든 데이터가 발행되면 이벤트 발생
- #### doOnError() : 중간에 에러가 발생하면 이벤트 발생
- #### doOnEach() : onNext, onComplete, onError 이벤트를 한번에 처리
- #### doOnSubscribe() : Observable을 구독했을때, 호출
- #### doOnDispose() : Observable의 구독이 해지되었을때 호출

## 예외 처리
> 위와 똑같은 이유로 예외처리도 할 수 없다. 역시 RxJava에서 지원하는 함수로 예외를 처리하자

#### onErrorReturn(): RxJava에서는 에러도 어떠한 데이터로 보는것이 적절합니다. 그렇기 때문 예외가 발생하면, 에러를 의미하는 다른 데이터로 대체를 합니다.
#### onError와 onErrorReturn()의 차이점
예외 발생이 예상되는 부분을 선언적으로 처리할 수 있습니다.
Observable을 생성하는 측에서 발생할 수 있는 예외 처리를 미리 해두면 그에 맞게 해결이 될 수 있습니다.
#### onErrorReturnItem(): onErrorReturn() 함수와 비슷하지만 중간에 에러를 넘기는 부분을 구현안해도 되기 때문에 좀 더 간결해집니다.
#### onErrorResumeNext(): onErrorResumeNext()는 에러가 발생했을 때 내가 원하는 Observable로 대체합니다.
이용할 수 있는 케이스로는 에러 발생시 기본값을 준다던가, 관리자에게 알람을 준다든가, 자원을 해제하는 등의 추가 작업을 할 수 있습니다.

#### retry(): 서버 연결과 같이 인터넷이 일시적으로 연결이 안될때는 재 요청을 해야하는데 이때 retry()를 사용합니다.
#### retryUntil(): 조건이 만족할때까지 재시도 하는 함수입니다.
#### retryWhen(): 재시도 조건을 동적으로 설정해야 하는 복잡한 로직을 구현할 때 활용합니다.


## 흐름 제어
> 흐름 제어는 Observable이 데이터를 발행하는 속도와 옵저버가 데이터를 받아서 처리하는 속도 사이의 시간 차이가 발생할 때 사용하는 함수입니다.

sample() : 특정 시간 동안 여러 데이터가 들어왔을때 마지막 데이터만 발행하고 나머지는 무시
buffer() : 일정 시간 동안 데이터를 모아두었다가 한꺼번에 발행해주기 때문에, 넘치는 데이터 흐름을 제어할때 사용
throttleFirst() : 주어진 조건에서 가장 먼저 입력된 값을 발행
throttleLast() : 함수는 주어진 조건에서 가장 마지막 입력된 값을 발행
window() : groupBy() 함수 같이 특정 조건에 맞는 입력값들을 그룹화 해서 별도의 Observable을 병렬로 만듦
debounce() : 연속 이벤트를 처리하는 함수로, 예를 들어 빠르게 버튼을 누를때 마지막 누른 버튼만 처리해야할 때 사용














sample() 함수
특정 시간 동안 여러 데이터가 들어왔을때 마지막 데이터만 발행하고 나머지는 무시합니다.




buffer() 함수
일정 시간 동안 데이터를 모아두었다가 한꺼번에 발행해주기 때문에, 넘치는 데이터 흐름을 제어할때 사용합니다.



throttleFirst(), throttleLast() 함수
throttleFirst() 함수는 주어진 조건에서 가장 먼저 입력된 값을 발행하고, throttleLast() 함수는 가장 마지막에 입력된 값을 발행합니다.




window() 함수
groupBy() 함수 같이 특정 조건에 맞는 입력값들을 그룹화 해서 별도의 Observable을 병렬로 만듭니다.




debounce() 함수
연속 이벤트를 처리하는 함수로, 예를 들어 빠르게 버튼을 누를때 마지막 누른 버튼만 처리해야할 때 사용합니다.